architecture popov-v24 {
/*
	case				                24
	data word length	                2
	code model			                Stack machine
	spaces				                code, constants, data, stack
*/

registers:

	storage sp [16];                                        // Stack pointer
	storage ip [16];                                        // Program counter (Instruction pointer)

	storage inp [16];
	storage outp [16];

memory:

	range datamem [0x0000 .. 0xffff] { 						// Data memory
		cell = 16;
		endianess = little-endian;
		granularity = 2;
	}

	range constantmem [0x0000 .. 0xffff] {					// Constants memory
		cell = 16;
		endianess = little-endian;
		granularity = 2;
	}

	range stackmem [0x0000 .. 0xffff] {						// Stack memory
		cell = 16;
		endianess = little-endian;
		granularity = 2;
	}

	range progmem [0x0000 .. 0xffff] {						// Program memory
		cell = 16;
		endianess = little-endian;
		granularity = 2;
	}

instructions:
	instruction halt = { 1111 1111 1111 1111 } {};


	encode imm16 field = immediate [16];

	encode bank sequence = alternatives {
		d = {00},
		c = {01},
		s = {10},
		p = {11}
	}; // For later usage
	

	instruction push = { 1000, 0000, imm16 as value } {
		stackmem:2[sp] = value;
		sp = sp + 2;
		ip = ip + 3;                                            
	};

	instruction pop = { 1000, 0001 } {
    	sp = sp - 2;
    	stackmem:2[sp] = 0;
    	ip = ip + 1;
  	};

  	instruction popout = { 1000, 0010 } {
    	sp = sp - 2;
    	outp = stackmem:2[sp];
    	stackmem:2[sp] = 0;
    	ip = ip + 1;
  	};

	instruction add = { 1000, 0100 } {
		sp = sp - 2;
	    let x = stackmem:2[sp];
		stackmem:2[sp] = 0;
	    
	    sp = sp - 2;
	    let y = stackmem:2[sp];
	    stackmem:2[sp] = 0;

	    let r = x + y;
	    
	    stackmem:2[sp] = r;
	    sp = sp + 2;
	    ip = ip + 1;
	};

	instruction sub = { 1000, 1000 } {
		sp = sp - 2;
	    let x = stackmem:2[sp];
	    stackmem:2[sp] = 0;

	    sp = sp - 2;
	    let y = stackmem:2[sp];
	    stackmem:2[sp] = 0;

	    let r = x - y;
	    
	    stackmem:2[sp] = r;
	    sp = sp + 2;
	    ip = ip + 1;
	};

	instruction mul = { 1001, 0000 } {
		sp = sp - 2;
	    let x = stackmem:2[sp];
	    stackmem:2[sp] = 0;

	    sp = sp - 2;
	    let y = stackmem:2[sp];
	    stackmem:2[sp] = 0;

	    let r = x * y;
	    
	    stackmem:2[sp] = r;
	    sp = sp + 2;
	    ip = ip + 1;
	};

	instruction div = { 1010, 0000 } {
		sp = sp - 2;
	    let x = stackmem:2[sp];
	    stackmem:2[sp] = 0;

	    sp = sp - 2;
	    let y = stackmem:2[sp];
	    stackmem:2[sp] = 0;

	    let r = x / y;
	    
	    stackmem:2[sp] = r;
	    sp = sp + 2;
	    ip = ip + 1;
	};

  	instruction call = { 1100, 0000, imm16 as target } {
			stackmem:2[sp] = ip + 3;
			sp = sp + 2;
			ip = target;
	};

	instruction ret = { 1100, 0001 } {
		sp = sp - 2;
    	let where_to = stackmem:2[sp];
    	stackmem:2[sp] = 0;
    	ip = where_to;
	};

	instruction jz = { 1100, 0010, imm16 as target } {
		let top = stackmem:2[sp - 2];
		if top == 0 then
			ip = target;
		else
			ip = ip + 3;
	};

	instruction jmp = { 1100, 0100, imm16 as target } {
    	ip = target;
  	};

  	instruction jmpgt = { 1100, 1000, imm16 as target } {
  		let top = stackmem:2[sp - 2];
  		let pretop = stackmem:2[sp - 4];
		if pretop > top then
			ip = target;
		else
			ip = ip + 3;
	};

	instruction jmplt = { 1101, 0000, imm16 as target } {
		let top = stackmem:2[sp - 2];
  		let pretop = stackmem:2[sp - 4];
		if pretop < top then
			ip = target;
		else
			ip = ip + 3;
	};


mnemonics:
	
	mnemonic push(value) "{1}";
	mnemonic pop();
	mnemonic popout();

	mnemonic add();
	mnemonic sub();
	mnemonic mul();
	mnemonic div();

	mnemonic jmp(target) "{1}";
	mnemonic jz(target) "{1}";
	mnemonic jmplt(target) "{1}";
	mnemonic jmpgt(target) "{1}";

	mnemonic call(target) "{1}";
	mnemonic ret();

	mnemonic halt();

}